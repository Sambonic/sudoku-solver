import random

class GeneticSolver2D(object):

    def __init__(self, board=None, target=None, chromosome=None):
        self.board = board
        self.target = target
        if chromosome is None:
            self.chromosome = self.create_gnome()
        else:
            self.chromosome = chromosome
        self.fitness = self.fitness()

    def mutated_board(self):
        return random.choice(self.board)

    def create_gnome(self):
        # Create chromosome with nested lists for 2D structure
        rows = len(self.target)
        cols = len(self.target[0])
        gnome = [[random.choice(self.board) for _ in range(cols)] for _ in range(rows)]
        return gnome

    def mate(self, parent2):
        child = []
        for row_index in range(len(self.chromosome)):
            child_row = []
            for col_index in range(len(self.chromosome[0])):
                prob = random.random()
                if prob < 0.48:
                    child_row.append(self.chromosome[row_index][col_index])
                elif prob < 0.96:
                    child_row.append(parent2.chromosome[row_index][col_index])
                else:
                    child_row.append(self.mutated_board())
            child.append(child_row)
        return GeneticSolver2D(parent2.board, parent2.target, child)

    def fitness(self):
        fitness = 0
        for row_index in range(len(self.chromosome)):
            for col_index in range(len(self.chromosome[0])):
                if self.chromosome[row_index][col_index] != self.target[row_index][col_index]:
                    fitness += 1
        return fitness
    
    def genetic_algorithm(self, population_list, population_size):
        generation = 1
        found = False
        population = population_list
        while not found:
            # sort the population in increasing order of fitness score
            population = sorted(population, key=lambda x: x.fitness)
            if population[0].fitness <= 0:
                found = True
                break
            # Generate new offsprings for new generation
            new_generation = []
            # Perform Elitism
            s = int(10 * population_size / 100)
            new_generation.extend(population[:s])
            s = int(90 * population_size / 100)
            for _ in range(s):
                parent1 = random.choice(population[:50])
                parent2 = random.choice(population[:50])
                child = parent1.mate(parent2)
                new_generation.append(child)
            population = new_generation
            print ('Generation: {}\tString: {}\tFitness: {}'.format(generation,''.join(population[0].chromosome),population[0].fitness))
            generation += 1
        print ('Generation: {}\tString: {}\tFitness: {}'.format(generation,''.join(population[0].chromosome),population[0].fitness))